<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogHeight" value="453" />
    <option name="newTranslationDialogWidth" value="783" />
    <option name="newTranslationDialogX" value="704" />
    <option name="newTranslationDialogY" value="282" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Module was compiled with an incompatible version of Kotlin. The binary version of its metadata is 1.6.0, expected version is 1.1.16" />
      <item value="The minCompileSdk (31) specified in a dependency's AAR metadata (META-INFcomandroidbuildgradleaar-metadata.properties) is greater than this module's compileSdkVersion (android-30). Dependency: androidx.core:core-ktx:1.7.0." />
      <item value="is greater than this module's compileSdkVersion" />
      <item value="The attr &quot;QMUIGroupListSectionViewStyle&quot; in values has no declaration in the base values folder; this can lead to crashes when the resource is queried in a configuration that does not match this qualifier" />
      <item value="This attribute is ignored in API level 14 ({@link android.os.Build.VERSION_CODESICE_CREAM_SANDWICH}) and higher. Using fading edges may introduce noticeable performance degradations and should be used only when required by the application's visual design. To request fading edges with API level 14 and above, use the &lt;code&gt;android:requiresFadingEdge&lt;code&gt; attribute instead. --&gt;" />
      <item value="fading Edge" />
      <item value="Newcomer" />
      <item value="point" />
      <item value="Personal Center" />
      <item value="My Collection" />
      <item value="Mine Collection" />
      <item value="Return true if we're nested scrolling vertically, and we either have lift on scroll enabled" />
      <item value="lifts on scroll or not" />
      <item value="Retrieves" />
      <item value="Retrieves the binding responsible for the given View layout root. If there is no binding, &lt;code&gt;null&lt;code&gt; will be returned. This uses the DataBindingComponent set in {@link setDefaultComponent(DataBindingComponent)}. @param &lt;T&gt; Type of the generated binding class. @param view The root &lt;code&gt;View&lt;code&gt; in the layout with binding. @return The ViewDataBinding associated with the given view or &lt;code&gt;null&lt;code&gt; if either the view is not a root View for a layout or view hasn't been bound." />
      <item value="Cannot make calls to a recycled instance" />
      <item value="the desired dimension unit for all sizes above" />
      <item value="Uniform horizontal and vertical text size scaling to fit within the container" />
      <item value="Returns the index of the group this position belongs. &lt;p&gt; For example, if grid has 3 columns and each item occupies 1 span, span group index for item 1 will be 0, item 5 will be 1. @param adapterPosition The position in adapter @param spanCount The total number of spans in the grid @return The index of the span group including the item at the given adapter position" />
      <item value="评论" />
      <item value="common" />
      <item value="Note that scroll position change will not be reflected until the next layout call." />
      <item value="The distance (in pixels) between the start edge of the item view and start edge of the RecyclerView." />
      <item value="attach" />
      <item value="Distance in pixels a touch can wander before we think the user is scrolling" />
      <item value="Dirty" />
      <item value="direction – Negative to check scrolling left, positive to check scrolling right" />
      <item value="is incompatible with attribute" />
      <item value="original" />
      <item value="enter" />
      <item value="菜单" />
      <item value="Millis" />
      <item value="Mills" />
      <item value="zone stay" />
      <item value="Cannot access database on the main thread since it may potentially lock the UI for a long period of time." />
      <item value="Cannot figure out how to save this field into database." />
      <item value="Embedded" />
      <item value="Returns flow where all subsequent repetitions of the same value are filtered out. Note that any instance of StateFlow already behaves as if distinctUtilChanged operator is applied to it, so applying distinctUntilChanged to a StateFlow has no effect. See StateFlow documentation on Operator Fusion. Also, repeated application of distinctUntilChanged operator on any flow has no effect." />
      <item value="chapter" />
      <item value="Comment" />
      <item value="Dubbing Binder" />
      <item value="indices" />
      <item value="Builds a LiveData that has values yielded from the given block that executes on a LiveDataScope. The block starts executing when the returned LiveData becomes active (LiveData.onActive). If the LiveData becomes inactive (LiveData.onInactive) while the block is executing, it will be cancelled after timeoutInMs milliseconds unless the LiveData becomes active again before that timeout (to gracefully handle cases like Activity rotation). Any value LiveDataScope.emited from a cancelled block will be ignored. After a cancellation, if the LiveData becomes active again, the block will be re-executed from the beginning. If you would like to continue the operations based on where it was stopped last, you can use the LiveDataScope.latestValue function to get the last LiveDataScope.emited value. If the block completes successfully or is cancelled due to reasons other than LiveData becoming inactive, it will not be re-executed even after LiveData goes through active inactive cycle. As a best practice, it is important for the block to cooperate in cancellation. See kotlin coroutines documentation for details https:kotlinlang.orgdocsreferencecoroutinescancellation-and-timeouts.html. a simple LiveData that receives value 3, 3 seconds after being observed for the first time. val data : LiveData&lt;Int&gt; = liveData { delay(3000) emit(3) }" />
      <item value="large Heap" />
      <item value="hardware Accelerated" />
      <item value="banned" />
      <item value="Launches and runs the given block when the [Lifecycle] controlling this [LifecycleCoroutineScope] is at least in [Lifecycle.State.RESUMED] state. The returned [Job] will be cancelled when the [Lifecycle] is destroyed. Caution: This API is not recommended to use as it can lead to wasted resources in some cases. Please, use the [Lifecycle.repeatOnLifecycle] API instead. This API will be removed in a future release. @see Lifecycle.whenResumed @see Lifecycle.coroutineScope" />
      <item value="public open operator fun equals( other: Any? ): Boolean Indicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following requirements: Reflexive: for any non-null value x, x.equals(x) should return true. Symmetric: for any non-null values x and y, x.equals(y) should return true if and only if y.equals(x) returns true. Transitive: for any non-null values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. Consistent: for any non-null values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified. Never equal to null: for any non-null value x, x.equals(null) should return false." />
      <item value="Max Scheduled Generation" />
      <item value="Chapter List" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="450" />
        <entry key="ENGLISH" value="451" />
        <entry key="FRENCH" value="2" />
        <entry key="CROATIAN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="JAPANESE" value="2" />
        <entry key="SOMALI" value="1" />
        <entry key="INDONESIAN" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1648881094795" />
  </component>
</application>